using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

// D_main.c

namespace HereticXNA
{
	public static class d_main
	{
		static public bool shareware = false; // true if only episode 1 present
		static public bool ExtendedWAD = false; // true if episodes 4 and 5 present

		static public bool nomonsters;			// checkparm of -nomonsters
		static public bool respawnparm;			// checkparm of -respawn
		static public bool debugmode;			// checkparm of -debug
		static public bool ravpic;				// checkparm of -ravpic
		static public bool cdrom;					// true if cd-rom mode active
		static public bool singletics = true;			// debug flag to cancel adaptiveness
		static public bool noartiskip;			// whether shift-enter skips an artifact

		static DoomDef.skill_t startskill = new DoomDef.skill_t();
		static public int startepisode;
		static public int startmap;
		static public bool autostart;

		static public bool advancedemo;

		//---------------------------------------------------------------------------
		//
		// FUNC FixedDiv
		//
		//---------------------------------------------------------------------------

		static public int FixedDiv(int a, int b)
		{
			if ((Math.Abs(a) >> 14) >= Math.Abs(b))
			{
				return (a ^ b) < 0 ? DoomDef.MININT : DoomDef.MAXINT;
			}
			else
			{
				Int64 result;
				result = ((Int64)a << 16) / b;
				return (int)result;
			}
		}

		/*
		===============================================================================

									EVENT HANDLING

		Events are asyncronous inputs generally generated by the game user.

		Events can be discarded if no responder claims them

		===============================================================================
		*/

		static public DoomDef.event_t[] events = new DoomDef.event_t[DoomDef.MAXEVENTS];
		static public int eventhead;
		static public int eventtail;

		//---------------------------------------------------------------------------
		//
		// PROC D_PostEvent
		//
		// Called by the I/O functions when input is detected.
		//
		//---------------------------------------------------------------------------

		static public void D_PostEvent(DoomDef.event_t ev)
		{
			events[eventhead] = ev;
			eventhead = (++eventhead) & (DoomDef.MAXEVENTS - 1);
		}

		//---------------------------------------------------------------------------
		//
		// PROC D_ProcessEvents
		//
		// Send all the events of the given timestamp down the responder chain.
		//
		//---------------------------------------------------------------------------

		static public void D_ProcessEvents()
		{
			DoomDef.event_t ev;

			for (; eventtail != eventhead; eventtail = (++eventtail) & (DoomDef.MAXEVENTS - 1))
			{
				ev = events[eventtail];
				if (f_finale.F_Responder(ev))
				{
					continue;
				}
				if (mn_menu.MN_Responder(ev))
				{
					continue;
				}
				g_game.G_Responder(ev);
			}
		}

		//---------------------------------------------------------------------------
		//
		// PROC DrawMessage
		//
		//---------------------------------------------------------------------------

		public static void DrawMessage()
		{
			DoomDef.player_t player;

			player = g_game.players[g_game.consoleplayer];
			if (player.messageTics <= 0 || player.message == null || player.message == "")
			{ // No message
				return;
			}
			mn_menu.MN_DrTextA(player.message, 160 - mn_menu.MN_TextAWidth(player.message) / 2, 1);
		}

		//---------------------------------------------------------------------------
		//
		// PROC D_Display
		//
		// Draw current display, possibly wiping it from the previous.
		//
		//---------------------------------------------------------------------------

		public static void D_Display()
		{
			// Change the view size if needed
#if DOS
	if(setsizeneeded)
#endif
			{ // [dsl] Lets say it's always needed for now
				r_main.R_ExecuteSetViewSize();
			}

			//
			// do buffered drawing
			//
			switch (g_game.gamestate)
			{
				case DoomDef.gamestate_t.GS_LEVEL:
					if (g_game.gametic == 0)
						break;
#if DOS
			if (automapactive)
				AM_Drawer ();
			else
#endif
					r_main.R_RenderPlayerView(g_game.players[g_game.displayplayer]);
#if DOS
			CT_Drawer();
#endif
					i_ibm.UpdateState |= DoomDef.I_FULLVIEW;
					sb_bar.SB_Drawer();
					break;
				case DoomDef.gamestate_t.GS_INTERMISSION:
			in_lude.IN_Drawer ();
					break;
				case DoomDef.gamestate_t.GS_FINALE:
#if DOS
			F_Drawer ();
#endif
					break;
				case DoomDef.gamestate_t.GS_DEMOSCREEN:
					D_PageDrawer();
					break;
			}

			if (g_game.paused && !mn_menu.MenuActive && !mn_menu.askforquit)
			{
				if (!g_game.netgame)
				{
					v_video.V_DrawPatch(160, r_draw.viewwindowy + 5, w_wad.W_CacheLumpName("PAUSED", DoomDef.PU_CACHE));
				}
				else
				{
					v_video.V_DrawPatch(160, 70, w_wad.W_CacheLumpName("PAUSED", DoomDef.PU_CACHE));
				}
			}
			// Handle player messages
			DrawMessage();

			// Menu drawing
			mn_menu.MN_Drawer();

			// Send out any new accumulation
			d_net.NetUpdate();
		}

		//---------------------------------------------------------------------------
		//
		// PROC D_DoomLoop
		//
		//---------------------------------------------------------------------------

		public static void D_DoomLoop()
		{
			if (m_misc.M_CheckParm("-debugfile") != 0)
			{
#if DOS
		char filename[20];
		sprintf(filename, "debug%i.txt", consoleplayer);
		debugfile = fopen(filename,"w");
#endif
			}
			//I_InitGraphics(); // [dsl] No need for that
		}

		// This is called every frame, it's a replacement for the update part of D_DoomLoop
		public static void D_Update()
		{
			// Frame syncronous IO operations
			//TODO: to catch joystick events
			//I_StartFrame();

			// Process one or more tics
			if (singletics) // In XNA we want to be single tics because it's handling the rest for us
			{
				i_ibm.I_StartTic();
				if (!Game1.instance.forcedPause)
				{
					D_ProcessEvents();
					g_game.G_BuildTiccmd(d_net.netcmds[g_game.consoleplayer, d_net.maketic % DoomDef.BACKUPTICS]);
					if (advancedemo)
						D_DoAdvanceDemo();
					g_game.G_Ticker();
					g_game.gametic++;
					d_net.maketic++;
					mn_menu.MN_Ticker();
				}
			}
			else
			{
				// Will run at least one tic
				d_net.TryRunTics();
			}

			// Move positional sounds
			i_ibm.S_UpdateSounds(g_game.players[g_game.consoleplayer].mo);
		}
		/*
		===============================================================================

								DEMO LOOP

		===============================================================================
		*/

		public static int demosequence;
		public static int pagetic;
		public static string pagename;


		/*
		================
		=
		= D_PageTicker
		=
		= Handles timing for warped projection
		=
		================
		*/

		public static void D_PageTicker()
		{
			if (--pagetic < 0)
				D_AdvanceDemo();
		}

		/*
		================
		=
		= D_PageDrawer
		=
		================
		*/

		public static void D_PageDrawer()
		{
			v_video.V_DrawRawScreen(w_wad.W_CacheLumpName(pagename, DoomDef.PU_CACHE));
			if (demosequence == 1)
			{
				v_video.V_DrawPatch(4, 160, w_wad.W_CacheLumpName("ADVISOR", DoomDef.PU_CACHE));
			}
			i_ibm.UpdateState |= DoomDef.I_FULLSCRN;
		}


		/*
		=================
		=
		= D_AdvanceDemo
		=
		= Called after each demo or intro demosequence finishes
		=================
		*/

		public static void D_AdvanceDemo()
		{
			advancedemo = true;
		}

		public static void D_DoAdvanceDemo()
		{
			g_game.players[g_game.consoleplayer].playerstate = DoomDef.playerstate_t.PST_LIVE;  // don't reborn
			advancedemo = false;
			g_game.usergame = false;               // can't save / end game here
			g_game.paused = false;
			g_game.gameaction = DoomDef.gameaction_t.ga_nothing;
			demosequence = (demosequence + 1) % 7;
			switch (demosequence)
			{
				case 0:
					pagetic = 210;
					g_game.gamestate = DoomDef.gamestate_t.GS_DEMOSCREEN;
					pagename = "TITLE";
					i_ibm.S_StartSong((int)sounds.musicenum_t.mus_titl, false);
					break;
				case 1:
					pagetic = 140;
					g_game.gamestate = DoomDef.gamestate_t.GS_DEMOSCREEN;
					pagename = "TITLE";
					break;
				case 2:
					//BorderNeedRefresh = true;
					i_ibm.UpdateState |= DoomDef.I_FULLSCRN;
					//TODO: G_DeferedPlayDemo("demo1");
					break;
				case 3:
					pagetic = 200;
					g_game.gamestate = DoomDef.gamestate_t.GS_DEMOSCREEN;
					pagename = "CREDIT";
					break;
				case 4:
					//BorderNeedRefresh = true;
					i_ibm.UpdateState |= DoomDef.I_FULLSCRN;
					//TODO: G_DeferedPlayDemo("demo2");
					break;
				case 5:
					pagetic = 200;
					g_game.gamestate = DoomDef.gamestate_t.GS_DEMOSCREEN;
					if (shareware)
					{
						pagename = "ORDER";
					}
					else
					{
						pagename = "CREDIT";
					}
					break;
				case 6:
					//BorderNeedRefresh = true;
					i_ibm.UpdateState |= DoomDef.I_FULLSCRN;
					//TODO: G_DeferedPlayDemo("demo3");
					break;
			}
		}


		/*
		=================
		=
		= D_StartTitle
		=
		=================
		*/

		public static void D_StartTitle()
		{
			g_game.gameaction = DoomDef.gameaction_t.ga_nothing;
			demosequence = -1;
			D_AdvanceDemo();
		}

#if DOS

/*
==============
=
= D_CheckRecordFrom
=
= -recordfrom <savegame num> <demoname>
==============
*/

void D_CheckRecordFrom (void)
{
	int     p;
	char    file[256];

	p = M_CheckParm ("-recordfrom");
	if (!p || p > myargc-2)
		return;

	if(cdrom)
	{
		sprintf(file, SAVEGAMENAMECD"%c.hsg",myargv[p+1][0]);
	}
	else
	{
		sprintf(file, SAVEGAMENAME"%c.hsg",myargv[p+1][0]);
	}
	G_LoadGame (file);
	G_DoLoadGame ();    // load the gameskill etc info from savegame

	G_RecordDemo (gameskill, 1, gameepisode, gamemap, myargv[p+2]);
	D_DoomLoop ();  // never returns
}

/*
===============
=
= D_AddFile
=
===============
*/
#endif
		public const int MAXWADFILES = 20;

		// MAPDIR should be defined as the directory that holds development maps
		// for the -wart # # command

		public const string MAPDIR = "\\data\\";

		public const string SHAREWAREWADNAME = "heretic1.wad";

		public static string[] wadfiles = new string[MAXWADFILES]
		{
			"heretic.wad",
			"texture1.lmp",
			"texture2.lmp",
			"pnames.lmp",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		};


		public const string basedefault = "heretic.cfg";

		public static string exrnwads;
		public static string exrnwads2;

		public static void wadprintf() // [dsl] This does nothing
		{
			if (debugmode)
			{
				return;
			}
		}

		public static void D_AddFile(string file)
		{
			int numwadfiles;
			string newFile;

			for (numwadfiles = 0; wadfiles[numwadfiles] != ""; numwadfiles++) ;
			newFile = file;
			if (exrnwads.Length + file.Length < 78)
			{
				if (exrnwads.Length > 0)
				{
					exrnwads += ", ";
				}
				else
				{
					exrnwads = "External Wadfiles: ";
				}
				exrnwads += file;
			}
			else if (exrnwads2.Length + file.Length < 79)
			{
				if (exrnwads2.Length > 0)
				{
					exrnwads2 += ", ";
				}
				else
				{
					exrnwads2 = "     ";
					exrnwads += ",";
				}
				exrnwads2 += file;
			}
			wadfiles[numwadfiles] = newFile;
		}

		//==========================================================
		//
		//  Startup Thermo code
		//
		//==========================================================
		public const int MSG_Y = 9;
		public const int THERMCOLOR = 3;
		public const int THERM_X = 14;
		public const int THERM_Y = 14;

		public static int thermMax;
		public static int thermCurrent;
		public static w_wad.CacheInfo startup;           // * to text screen
		public static string smsg;      // status bar line

		//
		//  Heretic startup screen shit
		//

		public static void drawstatus()
		{
			if (debugmode)
			{
				return;
			}
		}

		public static void status(string str)
		{
			smsg += str;
			drawstatus();
		}
		public static void DrawThermo()
		{
		}

		public static void CheckAbortStartup()
		{
		}

		public static void IncThermo()
		{
			thermCurrent++;
			DrawThermo();
			CheckAbortStartup();
		}

		public static void InitThermo(int max)
		{
			thermMax = max;
			thermCurrent = 0;
		}

		//---------------------------------------------------------------------------
		//
		// PROC D_DoomMain
		//
		//---------------------------------------------------------------------------

		public static void D_DoomMain()
		{
			int p;
			int e;
			int m;
			string file;
			byte[] fp;
			bool devMap;

			m_misc.M_FindResponseFile();
			nomonsters = m_misc.M_CheckParm("-nomonsters") != 0;
			respawnparm = m_misc.M_CheckParm("-respawn") != 0;
			ravpic = m_misc.M_CheckParm("-ravpic") != 0;
			noartiskip = m_misc.M_CheckParm("-noartiskip") != 0;
			debugmode = m_misc.M_CheckParm("-debug") != 0;
			startskill = DoomDef.skill_t.sk_medium;
			startepisode = 1;
			startmap = 1;
			autostart = false;


			// wadfiles[0] is a char * to the main wad
			if (!File.Exists("Content/" + wadfiles[0])) wadfiles[0] = SHAREWAREWADNAME;

			// Check for -CDROM
			cdrom = false;

			// -FILE [filename] [filename] ...
			// Add files to the wad list.
			p = m_misc.M_CheckParm("-file");
			if (p != 0)
			{	// the parms after p are wadfile/lump names, until end of parms
				// or another - preceded parm
				while (++p != m_misc.args.Length && m_misc.args[p][0] != '-')
				{
					D_AddFile(m_misc.args[p]);
				}
			}

			// -DEVMAP <episode> <map>
			// Adds a map wad from the development directory to the wad list,
			// and sets the start episode and the start map.
			devMap = false;
			p = m_misc.M_CheckParm("-devmap");
			if (p != 0 && p < m_misc.args.Length - 2)
			{
				e = m_misc.args[p + 1][0];
				m = m_misc.args[p + 2][0];
				file = "E" + (char)e + "M" + (char)m + ".wad";
				D_AddFile(file);
				Console.Write("DEVMAP: Episode " + (char)e + ", Map " + (char)m + ".\n");
				startepisode = e - (int)'0';
				startmap = m - (int)'0';
				autostart = true;
				devMap = true;
			}

			p = m_misc.M_CheckParm("-playdemo");
			if (p == 0)
			{
				p = m_misc.M_CheckParm("-timedemo");
			}
			if (p != 0 && p < m_misc.args.Length - 1)
			{
				file = m_misc.args[p + 1] + ".lmp";
				D_AddFile(file);
				Console.Write("Playing demo " + m_misc.args[p + 1] + ".lmp.\n");
			}

			//
			// get skill / episode / map from parms
			//
			if (m_misc.M_CheckParm("-deathmatch") != 0)
			{
				g_game.deathmatch = true;
			}

			p = m_misc.M_CheckParm("-skill");
			if (p != 0 && p < m_misc.args.Length - 1)
			{
				startskill = (DoomDef.skill_t)((int)m_misc.args[p + 1][0] - (int)'1');
				autostart = true;
			}

			p = m_misc.M_CheckParm("-episode");
			if (p != 0 && p < m_misc.args.Length - 1)
			{
				startepisode = (int)m_misc.args[p + 1][0] - (int)'0';
				startmap = 1;
				autostart = true;
			}

			p = m_misc.M_CheckParm("-warp");
			if (p != 0 && p < m_misc.args.Length - 2)
			{
				startepisode = (int)m_misc.args[p + 1][0] - (int)'0';
				startmap = (int)m_misc.args[p + 2][0] - (int)'0';
				autostart = true;
			}

			//
			// init subsystems
			//
			Console.Write("V_Init: allocate screens.\n");
			v_video.V_Init();

			// Load defaults before initing other systems
			Console.Write("M_LoadDefaults: Load system defaults.\n");
			m_misc.M_LoadDefaults();

			// [dsl] no mem management, we use C# :)
			//Console.Write("Z_Init: Init zone memory allocation daemon.\n");
			//Z_Init();

			Console.Write("W_Init: Init WADfiles.\n");
			w_wad.W_InitMultipleFiles(wadfiles);

			if (w_wad.W_CheckNumForName("E2M1") == -1)
			{ // Can't find episode 2 maps, must be the shareware WAD
				shareware = true;
			}
			else if (w_wad.W_CheckNumForName("EXTENDED") != -1)
			{ // Found extended lump, must be the extended WAD
				ExtendedWAD = true;
			}

			startup = w_wad.W_CacheLumpName("LOADING", DoomDef.PU_CACHE);

			//
			//  Build status bar line!
			//
			smsg = "";
			if (g_game.deathmatch)
				status("DeathMatch...");
			if (nomonsters)
				status("No Monsters...");
			if (respawnparm)
				status("Respawning...");
			if (autostart)
			{
				string temp = "Warp to Episode " + startepisode + ", Map " + startmap + ", Skill " + (startskill + 1);
				status(temp);
			}
			wadprintf(); // print the added wadfiles

			Console.Write("MN_Init: Init menu system.\n");
			mn_menu.MN_Init();

			ct_chat.CT_Init();

			r_main.R_Init();

			p_setup.P_Init();
			d_main.IncThermo();

			// [dsl] Interrupt stuff, we don't need this
			i_ibm.I_Init();
			IncThermo();

			d_net.D_CheckNetGame();
			d_main.IncThermo();

			sb_bar.SB_Init();
			d_main.IncThermo();


			//
			// start the apropriate game based on parms
			//

			//	D_CheckRecordFrom();

			p = m_misc.M_CheckParm("-record");
			if (p != 0 && p < m_misc.args.Length - 1)
			{
#if DOS
		G_RecordDemo(startskill, 1, startepisode, startmap, myargv[p+1]);
		D_DoomLoop(); // Never returns
#endif
			}

			p = m_misc.M_CheckParm("-playdemo");
			if (p != 0 && p < m_misc.args.Length - 1)
			{
				g_game.singledemo = true; // Quit after one demo
#if DOS
		G_DeferedPlayDemo(myargv[p+1]);
		D_DoomLoop(); // Never returns
#endif
			}

			p = m_misc.M_CheckParm("-timedemo");
			if (p != 0 && p < m_misc.args.Length - 1)
			{
#if DOS
		G_TimeDemo(myargv[p+1]);
		D_DoomLoop(); // Never returns
#endif
			}

			p = m_misc.M_CheckParm("-loadgame");
			if (p != 0 && p < m_misc.args.Length - 1)
			{
#if DOS
		if(cdrom)
		{
			sprintf(file, SAVEGAMENAMECD"%c.hsg", myargv[p+1][0]);
		}
		else
		{
			sprintf(file, SAVEGAMENAME"%c.hsg", myargv[p+1][0]);
		}
		G_LoadGame(file);
#endif
			}

			// Check valid episode and map
#if DOS
	if((autostart || netgame) && (devMap == false))
	{
		if(M_ValidEpisodeMap(startepisode, startmap) == false)
		{
			startepisode = 1;
			startmap = 1;
		}
	}
#endif

			if (g_game.gameaction != DoomDef.gameaction_t.ga_loadgame)
			{
				i_ibm.UpdateState |= DoomDef.I_FULLSCRN;
				//BorderNeedRefresh = true;
				if (d_main.autostart || g_game.netgame)
				{
					g_game.G_InitNew(startskill, startepisode, startmap);
				}
				else
				{
					D_StartTitle();
				}
			}
			D_StartTitle();
			///////////////////////////////
			Game1.instance.loadSounds();
			D_DoomLoop(); // Never returns [dsl] In our case, we do :)
		}
	}
}
